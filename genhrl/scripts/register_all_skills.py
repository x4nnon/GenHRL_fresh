#!/usr/bin/env python3
"""
Skill Registration Generator for GenHRL

This script scans all generated tasks and creates proper gym registrations
for all skills with task-specific naming to avoid conflicts between different
seeded versions of tasks.

Generates registrations in the format:
- Isaac-RobotFlat{TaskName}_{SkillName}-v0 for primitive skills
- Isaac-RobotComposite{TaskName}_{SkillName}-v0 for composite skills

Usage:
    python -m genhrl.scripts.register_all_skills --isaaclab-path ./IsaacLab [--robot G1] [--output-file path/to/__init__.py]
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass


@dataclass
class SkillInfo:
    """Information about a skill."""
    task_name: str
    skill_name: str
    is_primitive: bool
    module_path: str
    config_class_name: str


class SkillRegistrationGenerator:
    """Generates gym registrations for all skills in all tasks."""
    
    def __init__(self, isaaclab_path: str, robot: str = "G1"):
        self.isaaclab_path = Path(isaaclab_path)
        self.robot = robot
        
        # Import robot configuration helpers
        try:
            sys.path.append(str(Path(__file__).parent.parent / "generation"))
            from robot_configs import get_robot_folder_name
            robot_folder = get_robot_folder_name(robot)
        except ImportError:
            # Fallback for backward compatibility
            robot_folder = f"{robot}_generated"
        
        self.robot_folder = robot_folder
        self.skills_base_path = self.isaaclab_path / "source/isaaclab_tasks/isaaclab_tasks/manager_based" / robot_folder / "skills"
        
        if not self.skills_base_path.exists():
            raise FileNotFoundError(f"Skills base path not found: {self.skills_base_path}")
    
    def scan_all_tasks(self) -> Dict[str, List[SkillInfo]]:
        """Scan all task directories and extract skill information."""
        task_skills = {}
        
        print(f"Scanning for tasks in: {self.skills_base_path}")
        
        # Find all task directories (those with skill_library.json)
        for task_dir in self.skills_base_path.iterdir():
            if not task_dir.is_dir() or task_dir.name.startswith('__'):
                continue
                
            skill_library_path = task_dir / "skill_library.json"
            if not skill_library_path.exists():
                continue
                
            print(f"Found task: {task_dir.name}")
            
            # Load skill library
            try:
                with open(skill_library_path, 'r') as f:
                    skill_library = json.load(f)
                
                skills = self._extract_skills_from_library(task_dir.name, skill_library)
                task_skills[task_dir.name] = skills
                
                print(f"  Found {len(skills)} skills ({sum(1 for s in skills if s.is_primitive)} primitive, {sum(1 for s in skills if not s.is_primitive)} composite)")
                
            except Exception as e:
                print(f"  Error loading skill library: {e}")
                continue
        
        return task_skills
    
    def _extract_skills_from_library(self, task_name: str, skill_library: dict) -> List[SkillInfo]:
        """Extract skill information from a skill library."""
        skills = []
        
        if "skills" not in skill_library:
            return skills
        
        for skill_name, skill_data in skill_library["skills"].items():
            is_primitive = skill_data.get("is_primitive", False)
            
            # Build module path and config class names  
            # Note: skill directories use original case, but config files are lowercase
            module_path = f"isaaclab_tasks.manager_based.{self.robot_folder}.skills.{task_name}.skills.{skill_name}.{skill_name.lower()}_cfg"
            
            skill_info = SkillInfo(
                task_name=task_name,
                skill_name=skill_name,
                is_primitive=is_primitive,
                module_path=module_path,
                config_class_name="RobotFlatEnvCfg"  # All skills use RobotFlatEnvCfg
            )
            
            skills.append(skill_info)
        
        return skills
    
    def generate_registration_code(self, task_skills: Dict[str, List[SkillInfo]]) -> str:
        """Generate the gym registration code for all skills."""
        lines = []
        
        # Header
        lines.append("import gymnasium as gym")
        lines.append("")
        lines.append("# Auto-generated skill registrations")
        lines.append("# Generated by genhrl.scripts.register_all_skills")
        lines.append("")
        
        # Group by task for organization
        for task_name, skills in sorted(task_skills.items()):
            lines.append(f"# Task: {task_name}")
            lines.append("")
            
            # Sort skills: primitives first, then composites
            primitive_skills = [s for s in skills if s.is_primitive]
            composite_skills = [s for s in skills if not s.is_primitive]
            
            for skill in primitive_skills + composite_skills:
                lines.extend(self._generate_skill_registration(skill))
                lines.append("")
        
        return "\n".join(lines)
    
    def _generate_skill_registration(self, skill: SkillInfo) -> List[str]:
        """Generate registration code for a single skill."""
        # Create unique gym ID with task name to avoid conflicts
        gym_id_base = f"{skill.task_name}_{skill.skill_name}"
        prefix = "Isaac-RobotFlat" if skill.is_primitive else "Isaac-RobotComposite"
        gym_id = f"{prefix}{self._to_title_case(gym_id_base)}-v0"
        
        # Generate registration
        # Choose correct YAML config file based on skill type
        yaml_config = "skrl_ppo_cfg.yaml" if skill.is_primitive else "skrl_ppo_l1_cfg.yaml"
        
        lines = [
            f"# {'Primitive' if skill.is_primitive else 'Composite'} Skill: {skill.skill_name} (from {skill.task_name})",
            "gym.register(",
            f'    id="{gym_id}",',
            f'    entry_point="isaaclab.envs:ManagerBasedRLEnv",',
            f"    kwargs={{",
            f'        "env_cfg_entry_point": "{skill.module_path}:{skill.config_class_name}",',
            f'        "skrl_cfg_entry_point": f"{{__name__}}.skills.{skill.task_name}.skills.{skill.skill_name}.agents:{yaml_config}",',
            f"    }},",
            f")"
        ]
        
        return lines
    
    def _to_title_case(self, text: str) -> str:
        """Convert text to title case for gym IDs, handling underscores."""
        # Split by underscores and capitalize each part
        parts = text.split('_')
        return ''.join(part.capitalize() for part in parts)
    
    def update_init_file(self, task_skills: Dict[str, List[SkillInfo]], output_file: Optional[Path] = None, clean_first: bool = True) -> None:
        """Update the __init__.py file with all registrations.
        
        Args:
            task_skills: Dictionary of task skills to register
            output_file: Output file path (defaults to __init__.py)
            clean_first: Whether to clean the file first (remove existing content)
        """
        if output_file is None:
            output_file = self.skills_base_path.parent / "__init__.py"
        
        if clean_first:
            print(f"üßπ Cleaning existing registrations in: {output_file}")
            # Backup the old file first
            backup_file = output_file.with_suffix('.py.backup')
            if output_file.exists():
                import shutil
                shutil.copy2(output_file, backup_file)
                print(f"   üìã Backup created: {backup_file}")
        
        registration_code = self.generate_registration_code(task_skills)
        
        # Write the registration code (this overwrites the file completely)
        with open(output_file, 'w') as f:
            f.write(registration_code)
            
        print(f"‚úÖ Updated registration file: {output_file}")
        
        # Show summary
        total_skills = sum(len(skills) for skills in task_skills.values())
        total_primitive = sum(sum(1 for s in skills if s.is_primitive) for skills in task_skills.values())
        total_composite = total_skills - total_primitive
        
        print(f"Generated {total_skills} registrations:")
        print(f"  - {total_primitive} primitive skills")
        print(f"  - {total_composite} composite skills")
        print(f"  - {len(task_skills)} tasks")
    
    def print_registration_summary(self, task_skills: Dict[str, List[SkillInfo]]) -> None:
        """Print a summary of what would be registered."""
        print("\nRegistration Summary:")
        print("=" * 80)
        
        for task_name, skills in sorted(task_skills.items()):
            print(f"\nTask: {task_name}")
            
            primitive_skills = [s for s in skills if s.is_primitive]
            composite_skills = [s for s in skills if not s.is_primitive]
            
            if primitive_skills:
                print(f"  Primitive skills ({len(primitive_skills)}):")
                for skill in primitive_skills:
                    gym_id_base = f"{skill.task_name}_{skill.skill_name}"
                    gym_id = f"Isaac-RobotFlat{self._to_title_case(gym_id_base)}-v0"
                    print(f"    - {gym_id}")
            
            if composite_skills:
                print(f"  Composite skills ({len(composite_skills)}):")
                for skill in composite_skills:
                    gym_id_base = f"{skill.task_name}_{skill.skill_name}"
                    gym_id = f"Isaac-RobotComposite{self._to_title_case(gym_id_base)}-v0"
                    print(f"    - {gym_id}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Generate gym registrations for all GenHRL skills",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate registrations and update __init__.py (uses ./IsaacLab by default)
  python -m genhrl.scripts.register_all_skills
  
  # Just show what would be registered (dry run)
  python -m genhrl.scripts.register_all_skills --dry-run
  
  # Use custom IsaacLab path
  python -m genhrl.scripts.register_all_skills --isaaclab-path /path/to/IsaacLab
  
  # Don't clean existing registrations (append mode - not recommended)
  python -m genhrl.scripts.register_all_skills --no-clean
  
  # Save to custom file
  python -m genhrl.scripts.register_all_skills --output-file custom_init.py
        """
    )
    
    parser.add_argument("--isaaclab-path", default="./IsaacLab", help="Path to IsaacLab installation (default: ./IsaacLab)")
    parser.add_argument("--robot", default="G1", help="Robot name (default: G1)")
    parser.add_argument("--output-file", help="Output file path (default: update existing __init__.py)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be registered without writing files")
    parser.add_argument("--no-clean", action="store_true", help="Don't clean existing registrations (append instead of replace)")
    
    args = parser.parse_args()
    
    # Verify IsaacLab path
    isaaclab_path = Path(args.isaaclab_path).resolve()
    if not isaaclab_path.exists():
        print(f"Error: IsaacLab path does not exist: {isaaclab_path}")
        sys.exit(1)
    
    try:
        # Create generator
        generator = SkillRegistrationGenerator(
            isaaclab_path=str(isaaclab_path),
            robot=args.robot
        )
        
        # Scan all tasks
        task_skills = generator.scan_all_tasks()
        
        if not task_skills:
            print("No tasks with skills found!")
            sys.exit(1)
        
        # Show summary
        generator.print_registration_summary(task_skills)
        
        if not args.dry_run:
            clean_mode = "with cleanup" if not args.no_clean else "append mode"
            print(f"\nüìù Registration mode: {clean_mode}")
            if not args.no_clean:
                print("   üßπ Existing registrations will be cleaned and backed up")
            else:
                print("   ‚ö†Ô∏è  Existing registrations will be preserved (may cause conflicts)")
        
        # Update file or show dry run
        if args.dry_run:
            print(f"\nüîç Dry run mode - no files will be modified")
            print("Generated registration code:")
            print("=" * 80)
            print(generator.generate_registration_code(task_skills))
        else:
            output_file = Path(args.output_file) if args.output_file else None
            generator.update_init_file(task_skills, output_file, clean_first=not args.no_clean)
            print(f"\n‚úÖ Skill registrations generated successfully!")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()